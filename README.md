## OTUS обучение


**Домашнее задание №1.**
Цель задания – создание сборочной фермы для простого приложения c запуском тестов и
генерацией релизов.

Написать программу, выводящую на консоль две строки:

build N

Hello, World!
, где вместо N должен выводится текущий номер сборки. Запустить на этапе сборки тесты,
проверяющие валидность номера версии. Выложить исходные тексты в репозиторий на github.
Настроить Github Actions workflow для автоматической сборки проекта на каждый коммит. Так же
настроить автоматический выпуск релиза либо на каждый коммит, либо по созданию тэга.

Вариант организации исходников по самостоятельным работам:
-  отдельная директория в одной и той же ветке одного и того же репозитория

**Домашнее задание №2.**
Фильтрация IP-адресов

Цель задания – реализовать приложение обработки списка IP-адресов.

Программа из стандартного ввода читает данные. Данные хранятся построчно. Каждая строка
состоит из трех полей, разделенных одним символом табуляции, и завершается символом конца
строки. 
Формат строки:

text1 \t text2 \t text3 \n

Поля text2 и text3 игнорируются. Поле text1 имеет следующую структуру (ip4 address):

n1.n2.n3.n4
где n1..4 – целое число от 0 до 255.
Требуется загрузить список ip-адресов в память и отсортировать их в обратном
лексикографическом порядке. Пример лексикографической сортировки (по первому числу, затем
по второму и так далее):

1.1.1.1

1.2.1.1

1.10.1.1

Соответственно, обратная:

1.10.1.1

1.2.1.1

1.1.1.1

Далее выводим в стандартный вывод следующее:

1. Полный список адресов после сортировки. Одна строка - один адрес.
2. Сразу следом список адресов, первый байт которых равен 1. Порядок сортировки не меняется.
Одна строка - один адрес. Списки ничем не разделяются.
3. Сразу продолжается список адресов, первый байт которых равен 46, а второй 70. Порядок
сортировки не меняется. Одна строка - один адрес. Списки ничем не разделяются.
4. Сразу продолжается список адресов, любой байт которых равен 46. Порядок сортировки не
меняется. Одна строка - один адрес. Списки ничем не разделяются.

**Домашнее задание №3.**
Реализовать свой аллокатор памяти, который позволит выполнять операцию резервирования
памяти. Далее использовать этот аллокатор с контейнером std::map. Аллокатор должен
параметризоваться количеством выделяемых за раз элементов. Освобождение конкретного
элемента не предполагается - аллокатор должен освобождать всю память самостоятельно.
Аллокатор работает с фиксированным количеством элементов. Попытку выделить большее числоэлементов считать ошибкой.

Опционально реализовать расширяемость аллокатора. При попытке выделить число элементов,
которое превышает текущее зарезервированное количество, аллокатор расширяет
зарезервированную память.

Опционально реализовать поэлементное освобождение.

Цель такого аллокатора – снизить количество операций выделения памяти.

Реализовать свой контейнер, который по аналогии с контейнерами stl параметризуется
аллокатором. Контейнер должен иметь две возможности - добавить новый элемент и обойти
контейнер в одном направлении.
Опционально реализовать совместимость с контейнерами stl – итераторы, вспомогательные
методы size, empty и т.д.

Цель реализации своего контейнера – попробовать использовать std::allocator, а также свой
аллокатор. 